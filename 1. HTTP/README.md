# HTTP

### 🤔 HTTP를 간략하게 설명해주세요.

<details>
<summary>자세히 보기</summary>

> HTTP는 Hyper Text Transfer Protocol의 약자로, 서버/클라이언트 간 웹페이지 같은 자원을 주고받을 때 쓰는 통신 규약으로, WWW상에서 웹페이지나 이미지 같은 정보를 요청과 응답에 의해 주고받는 프로토콜입니다.

웹 브라우저 주소란에 URL을 입력했을 때 어떻게 웹 페이지가 보여질까요? 웹 브라우저는 웹 브라우저 주소 입력란에 지정된 URL에 의지해서 웹 서버로부터 리소스라고 불리는 파일등의 정보를 얻고 있는 것 입니다.

이 때, 서버에 의뢰를 하는 웹 브라우저는 클라이언트, 요청을 보내는 곳은 웹 서버라고 합니다.

</details>

### 🤔 HTTP는 stateless한 프로토콜이라고 하는데 그 의미가 무엇일까요?

<details>
<summary>자세히 보기</summary>

> HTTP는 상태를 유지하지 않는 스테이트리스(stateless) 프로토콜입니다. 응답과 요청을 주고 받는 동안에 상태를 관리하지 않습니다.

클라이언트: 전에 뭘 보냈었지? 서버: 전에 뭘 보냈었지?

그래서 HTTP에서 요청을 보낼 때 마다 새로운 응답이 생성됩니다. 과거의 데이터를 전혀 가지고 있지 않습니다. HTTP는 많은 데이터를 매우 빠르고 확실하게 처리하는 범위성(scalability)를 확보하기 위해서 이와 같이 간단하게 설계되어 있습니다.

</details>

### 🤔 HTTP는 stateless해서 상태값을 사용할 수 없는데 그 대안으로 무엇을 사용할 수 있을까요?

<details>
<summary>자세히 보기</summary>

HTTP 스테이트리스의 단점을 보완하기 위해서 쿠키(cookie) 시스템이 도입되었습니다. 쿠키는 서버에서 응답으로 보내진 Set-Cookie라는 헤더 필드에 의해 쿠키를 클라이언트에 보존하게 됩니다. 다음 번에 클라이언트가 같은 서버로 요청을 보내면 자동적으로 쿠키를 싣어서 송신합니다. 이렇게 서버는 클라이언트가 자동적으로 같이 보낸 쿠키를 통해서 상태를 관리하고 체크해서 그에 맞는 응답을 보내줄 수 있습니다.

</details>

### 🤔 HTTP GET 메서드와 POST 메서드의 차이점이 무엇일까요?

<details>
<summary>자세히 보기</summary>

#### GET

- GET은 불필요한 요청을 제한하기 위해 요청이 캐시될 수 있습니다.
- 파라미터에 내용이 노출되기 때문에 민감한 데이터를 다룰 때 GET 요청을 사용해서는 안 됩니다.
- GET 요청은 브라우저 기록에 남습니다.
- GET 요청을 북마크에 추가할 수 있습니다.
- GET 요청에는 데이터 길이에 대한 제한이 있습니다.
- Get 요청은 성공시, 200(Ok) HTTP 응답 코드를 XML, JSON뿐만 아니라 여러 데이터(html, txt등..), 여러 형식의 데이터와 함께 반환합니다.
- GET 요청은 **idempotent**합니다.

#### POST

- POST 요청은 캐시되지 않습니다.
- POST 요청은 브라우저 기록에 남아 있지 않습니다.
- POST 요청을 북마크에 추가할 수 없습니다.
- POST 요청에는 데이터 길이에 대한 제한이 없습니다.
- Post 요청 중 자원 생성은 201(Created) HTTP 응답 코드를 반환합니다.
- Post 요청은 **idempotent**하지 않습니다.

|                       | GET         | POST         |
| --------------------- | ----------- | ------------ |
| 캐시                  | ⭕️         | ❌           |
| 브라우저 기록         | ⭕️         | ❌           |
| 북마크 추가           | ⭕️         | ❌           |
| 데이터 길이 제한      | ⭕️         | ❌           |
| HTTP 응답 코드        | 200(Ok)     | 201(Created) |
| 언제 주로 사용하는가? | 리소스 요청 | 리소스 생성  |
| 리소스 전달 방식      | 쿼리스트링  | HTTP Body    |
| idempotent            | ⭕️         | ❌           |

**idempotent = `연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질`**

`GET` 방식은 당연히 DB에서 데이터를 읽어오는데에 사용하기 때문에 연산의 결과가 똑같습니다.

`POST` 메서드는 DB에 리소스 생성, 또는 변경시킬 때 사용되기 때문에 연산의 결과가 달라집니다.

이처럼 `POST` 는 생성, 수정, 삭제에 사용할 수 있지만, 생성에는 **`POST`**, 수정은 **`PUT`** 또는 **`PATCH`**, 삭제는 **`DELETE`** 가 더 용도에 맞는 메소드라고 할 수 있습니다.

</details>

### 🤔 HTTP에서 비연결성이 무엇일까요?

<details>
<summary>자세히 보기</summary>

HTTP가 TCP의 3-way handshake통해 **세션을 열고, 1번의 세션 안에서 클라이언트는 서버로 요청을 보내고 서버로 응답을 받으면 세션이 끊어지는 단점**이 있습니다.

이런 단점을 극복하기 위해서 **HTTP1.1에서 Keep-Alive기능**을 제공하여 한 번에 여러 요청-응답이 가능해졌다.

</details>

### 🤔 SOP(Same-Origin-Policy)에 대해 설명해주세요.

<details>
<summary>자세히 보기</summary>

다른 도메인으로부터 리소스가 요청될 경우 해당 리소스는 cross-origin HTTP 요청에 의해 요청됩니다. 하지만 대부분의 브라우저들은 보안 상의 이유로 스크립트에서의 cross-origin HTTP 요청을 제한합니다. 이것을 Same-Origin-Policy, 동일 출처 정책이라고 합니다.

SOP는 어떤 출처에서 불러온 문서나 스크립트가 다른 출처에서 가져온 리소스와 상호작용하는 것을 제한하는 중요한 보안 방식으로, 잠재적으로 해로울 수 있는 문서를 분리함으로써 공격받을 수 있는 경로를 줄여 줍니다.

요청을 보내기 위해서는 요청을 보내고자 하는 대상과 프로토콜도 같아야 하고, (명시한 경우) 포트, 호스트도 같아야 함을 의미합니다.(이 때, 서브 도메인 네임은 상관없다.) 다만 태그를 사용한 embedding 방식은 가능합니다.

</details>

### 🤔 CORS (Cross-Origin Resource Sharing)에 대해 설명해주세요.

<details>
<summary>자세히 보기</summary>

CORS는 cross-origin HTTP 요청이 제한되는 문제(SOP)를 해결하기 위한 것으로, '타 도메인 간에 자원을 공유할 수 있게 해주는 것'입니다.

Cross-Origin Resource Sharing 표준은 웹 브라우저가 사용하는 정보를 읽을 수 있도록 허가된 출처 집합을 서버에게 알려주도록 허용하는 특정 HTTP 헤더를 추가함으로써 동작한다.

특정 헤더 : Access-Control-Allow-Origin 응답 헤더 : 서버 → 클라이언트

</details>

### 🤔 HTTP와 HTTPS에 대해 설명해주세요.

<details>
<summary>자세히 보기</summary>

HTTP는 웹 상에서 클라이언트와 서버 간에 요청/응답(request/response)으로 정보를 주고 받을 수 있는 프로토콜이며 TCP와 UDP를 사용하며, 80번 포트를 사용합니다. 비연결, 무상태를 특징으로 합니다.

HTTPS는 웹 통신 프로토콜인 HTTP의 보안이 강화된 버전의 프로토콜이며 기본 TCP/IP 포트로 443번 포트를 사용합니다. 소켓 통신에서 일반 텍스트를 이용하는 대신에, 웹 상에서 정보를 암호화하는 SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화하며 데이터의 적절한 보호를 보장합니다.

HTTP는 평문 통신이므로 도청이 가능하며(TCP/IP), 통신 상대를 확인하지 않아 위장이 가능하며, 완전성(정보의 정확성)을 증명할 수 없어 변조가 가능합니다.

이러한 문제점들을 보완한 방식이 HTTP 통신 소켓 부분을 SSL 이나 TLS 프로토콜로 대체한 HTTPS입니다. HTTP는 TCP와 직접 통신 했지만, HTTPS에서 HTTP는 SSL과 통신하고 SSL이 TCP와 통신하게 됩니다. SSL을 사용한 HTTPS는 암호화와 증명서, 안전성 보호를 이용할 수 있게 됩니다.

</details>

### 🤔 쿠키와 세션에 대해 설명해주세요.

<details>
<summary>자세히 보기</summary>

쿠키는 클라이언트 로컬에 저장되는 키와 값이 들어있는 파일이며, 클라이언트의 상태 정보를 브라우저에 저장하여 참조할 수 있게 해줍니다.

세션은 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태입니다.

HTTP 프로토콜은 모든 요청 간 의존관계가 없습니다. 즉, 현재 접속한 사용자가 이전에 접속했던 사용자와 같은 사용자인지 아닌지 알 수 있는 방법이 없습니다.

계속해서 연결을 유지하지 않기 때문에 리소스 낭비가 줄어드는 것이 큰 장점이지만, 통신할 때마다 새로 연결하기 때문에 클라이언트는 매 요청마다 인증을 해야 한다는 것이 단점입니다.

이전 요청과 현재 요청이 같은 사용자의 요청인지 알기 위해서는 상태를 유지해야 하는데, 이 때 필요한 기술이 쿠키와 세션입니다.

차이점은, 쿠키는 클라이언트에 세션은 서버에 저장됩니다. 쿠키는 보안에 취약하나 세션은 비교적 좋습니다. 쿠키는 브라우저 종료 시 남아있지만 세션은 만료 시간에 상관없이 브라우저 종료 시 삭제됩니다. 쿠키는 클라이언트에 저장되어 있어 속도가 빠르지만 세션은 서버에 저장되어 쿠키보다 느립니다.

</details>

### 🤔 OSI 7 계층에 대해 설명해주세요.

<details>
<summary>자세히 보기</summary>

OSI 모델은 국제표준화기구(ISO)에서 개발한 모델로, 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것입니다.

OSI 7 계층은 패킷 기반 통신으로서 각 계층의 순서와 담당하는 기술과 방식에 따라 데이터를 종단 to 종단으로 전달하며 우리가 평소에 사용하는 LTE, 5G을 이 모델로 설명할 수 있습니다.

1 계층인 물리계층은 전기, 물리 신호에 따른 계층이며 단순한 전기적 신호 전달 역할을 합니다. 단위는 Bit를 쓰며 전선, 광케이블, 무선 전파 등이 여기에 해당합니다.

2 계층인 데이터 링크 계층은 1 계층의 물리적 링크인 MAC 주소를 참조해 장비 간 데이터 전송합니다. 전송하는 데이터(비트 모음)의 헤더에 목적지 주소를 붙이며 꼬리 부분에는 오류 검출을 위한 부분이 붙습니다. 이러한 데이터 구성을 프레임(frame)이라고 합니다. 그래서 물리 계층에서 발생할 수 있는 오류를 찾고 수정하는데 필요한 기능/절차들을 제공합니다. L2 스위치 장비, 브릿지, 이더넷, ARP 등의 프로토콜/기술들이 여기에 포함됩니다.

3 계층인 네트워크 계층은 데이터가 담긴 패킷의 경로를 설정하는 계층입니다. IP 주소를 할당하는 논리 주소 기능, IP 주소 기반을 네트워크 구분하는 라우팅 기능, 최적 경로 설정 기능이 있으며 IP, ICMP 등의 프로토콜/기술들이 포함됩니다.

4 계층인 전송 계층은 각 종단 간 데이터 전송의 전반적 조율을 담당합니다.

여기선, 세그먼트(쪼개진 데이터 유닛)를 포트 번호로 구분하여 각 응용 계층이 나눠 받도록 하는 분할 작업, 서로 다른 장비 간 각기 다른 대역폭 속도 맞추는 흐름 제어 작업, 수신 못한 세그먼트만을 재송신하는 오류제어 작업, 데이터 수신 유/무 확인을 하는 연결형 작업, 데이터 수신 유/무 확인을 안 하는 비연결형 작업의 기능이 있습니다. TCP, UDP 등의 프로토콜/기술이 포함됩니다.

5 계층인 세션 계층은 데이터가 서로 만나는 환경 조성 단계이며 인증에 따른 권한 부여를 합니다. TLS, SSH 등의 프로토콜/기술이 포함됩니다.

6 계층인 표현 계층은 데이터를 빠르고 안전하게 전송하기 위해 데이터 압축, 암호화/복호화 단계입니다. SSL, JPEG, MPEG 등의 프로토콜/기술이 포함됩니다.

7 계층인 응용 계층은 도착 데이터를 브라우저나 메일, 메신저 같은 수단으로 최종 사용자가 확인하는 단계로 HTTP, HTTPS, SNMP, FTP, POP3 같은 프로토콜이 포함됩니다.

</details>

<details>
<summary>자세히 보기</summary>

쿠키는 클라이언트 로컬에 저장되는 키와 값이 들어있는 파일이며, 클라이언트의 상태 정보를 브라우저에 저장하여 참조할 수 있게 해줍니다.

세션은 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태입니다.

HTTP 프로토콜은 모든 요청 간 의존관계가 없습니다. 즉, 현재 접속한 사용자가 이전에 접속했던 사용자와 같은 사용자인지 아닌지 알 수 있는 방법이 없습니다.

계속해서 연결을 유지하지 않기 때문에 리소스 낭비가 줄어드는 것이 큰 장점이지만, 통신할 때마다 새로 연결하기 때문에 클라이언트는 매 요청마다 인증을 해야 한다는 것이 단점입니다.

이전 요청과 현재 요청이 같은 사용자의 요청인지 알기 위해서는 상태를 유지해야 하는데, 이 때 필요한 기술이 쿠키와 세션입니다.

차이점은, 쿠키는 클라이언트에 세션은 서버에 저장됩니다. 쿠키는 보안에 취약하나 세션은 비교적 좋습니다. 쿠키는 브라우저 종료 시 남아있지만 세션은 만료 시간에 상관없이 브라우저 종료 시 삭제됩니다. 쿠키는 클라이언트에 저장되어 있어 속도가 빠르지만 세션은 서버에 저장되어 쿠키보다 느립니다.

</details>

### 🤔 TCP, UDP 방식의 차이점을 설명해주세요.

<details>
<summary>자세히 보기</summary>

1. TCP와 UDP는 둘다 전송 계층에서 데이터를 보내기 위해 사용하는 프로토콜 입니다.
2. TCP는 연결형 서비스로 가상 회선 방식을 제공하고, 높은 신뢰성을 보장하고 흐름 제어 및 혼잡 제어 기능을 제공합니다.
3. UDP는 비연결형 서비스로 데이터그램 방식을 제공하고, 패킷에 순서 부여나 재조립등의 기능을 처리하지 않기 때문에 연속성이 중요한 서비스에 사용됩니다.

</details>

### 🤔 TCP의 3 Way-HandShake 와 4 Way-HandShake 에 대해 할고 있나요 ?

<details>
<summary>자세히 보기</summary>

**3 Way-HandShake**

TCP는 연결형 서비스 자원 프로토콜로써, 호스트 간 신뢰성 있는 전달과 흐름 제어를 가능하게 합니다.

이런 TCP는 장치들 사이에 논리적 접속 성립(establish)을 위해 3-way Handshake를 사용합니다.

3-way Handshake TCP/IP 프로토콜을 이용한 통신을 하는 응용 프로그램(브라우저)이 데이터를 전송하기 전, 먼저 정확한 전송을 보장하기 위해 사전에 세션을 수립하는 과정입니다. 즉, 양쪽 모두 데이터 전송 준비가 되었다는 것을 보장하고, 실제로 데이터 전달하기 전 한쪽이 다른 쪽의 준비 상태를 알 수 있도록 합니다.

순서는 SYN -> SYN / ACK -> ACK이며 상태가 Established가 되면 TCP Connection이라는 가상 통신 회선이 구성됩니다.

풀어서 이야기하면, A클라이언트가 B서버에 접속 요청을 하기 위해서 먼저, B에 SYN 패킷을 보내고 응답을 기다립니다. B는 SYN 요청을 받고 요청 수락한다는 ACK와 SYN flag 설정된 패킷을 발송하고 응답을 기다립니다. A는 B에게 다시 ACK를 보내고 B의 상태가 Established 되어 연결이 이뤄지고 데이터 송수신이 된다.

**4 Way-HandShake**

3 Way-HandShake가 TCP 연결 초기화할 때 사용한다면, 4 Way-HandShake는 세션을 종료하기 위해 수행됩니다.

먼저, A클라이언트가 B서버에 연결 종료를 위해 FIN flag 보냅니다. B는 ACK(확인 메시지)를 보내고 자신의 통신이 끝날 때까지 TIME_WAIT 상태가 됩니다. B의 통신이 끝나면, 연결 종료되었다고 A에게 FIN flag를 보냅니다. A는 확인 메시지를 보냅니다.

</details>

### 🤔 프록시 서버가 필요한 이유에 대해 설명해주세요.

<details>
<summary>자세히 보기</summary>

프록시 서버는 클라이언트가 자신을 통해서, **다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용프로그램을 말합니다.**

서버와 클라이언트 사이에 `**중계기**` 로서 대리로 통신을 수행하는 것을 가리켜 `**프록시**` 그 중계 기능을 하는 것을 **프록시 서버라고 부릅니다.**

**✅  주요 특징**

- PC 와 외부 인터넷 사이의 **징검다리 역할**
- 중계를 해주기 때문에, 외부 인터넷에서는 Client 의 정보를 알 수 없다.
- 외부 인터넷의 내부 침입을 막는 **방화벽과** 관련이 있다.
- Proxy Server 는 **캐시 기능**이 있다.
- IP 를 바꾸기 위한 용도로 많이 사용되고 있다.

**✅  목적**

- **보안** : 익명의 사용자가 서버에 접근하는 것을 막는다.
- **속도** : Proxy 서버는 사용자의 요청을 캐싱해서 동일 요청이 들어오면, 캐시 자원을 반환한다.
- A**CL(Access Control List)**: 사이트 접근에 대한 접근 정책을 정의할 수 있다.
- **log/Audit** : 회사 내 직원의 인터넷 사용을 레포팅할 수 있다.

</details>

### 🤔 Preflight Request 에 대해 설명해주세요.

<details>
<summary>자세히 보기</summary>

- 실제 요청을 보내도 안전한지 판단하기 위해 preflight 요청을 먼저 보낸다.
- Preflight Request는 actual 요청 전에 인증 헤더를 전송하여 서버의 허용 여부를 미리 체크하는 테스트 요청이다.
- 이 요청으로 트래픽이 증가할 수 있는데 서버의 헤더 설정으로 캐시가 가능
- 브라우저에서는 다른 도메인으로 보내게 될 때 해당 도메인에서 CORS를 허용하는지 알아보기 위해 preflight 요청을 보내는데 이에 대한 처리가 필요
- preflight 단계
  - ① 동일한 URI에 OPTION method로 요청을 보냄. (preflight)
  - ② ① 요청에 대해 서버에서는 허용되는 method , 허용하는 헤더, 쿠키 허용 여부 등을 응답
  - ③ ② 요청의 응답이 요청을 허용하는 조건이라면 실제로 요청을 보냄

</details>

### 🤔 URL, URI, URN의 차이점이 뭘까요?

<details>
<summary>자세히 보기</summary>

- URI : Uniform, Resource, Identifier 로 Identifier를 이용해서 이를 분리 합니다.
- URL : Locator로 리소스가 있는 위치를 지정 합니다.
- URN : Name을 통하여 분리하는데 이는 확인하기 힘들어서 안씀

</details>

### 🤔 HTTP 버전 1.0, 1.1, 2.0의 차이를 설명해 주세요.

<details>
<summary>자세히 보기</summary>

**HTTP/1.0 버전**에서는 요청을 보낼 때마다 연결했다 끊는 작업 반복해서 웹 페이지 로딩이 느렸음.

**HTTP/1.1 버전**에서는 `keepalive`라는 기능 추가. 연결을 한 번 수립하면 데이터 교환을 마칠때까지 유지하고, 끝나면 연결을 끊는 구조. 하지만 요청된 순서대로 작업을 처리해서 현재 요청이 오래걸리면 그 다음 요청들의 처리가 늦어지는 문제 발생.

**HTTP/2 버전**에서는 요청을 보낸 순서대로 응답하지 않아도 된다는 특징.

</details>

## 팀원들 정리 내용들

| 이름 | 링크                                                                     |
| ---- | ------------------------------------------------------------------------ |
| 현수 | [HTTP가 무엇일까](https://junghyeonsu-dev.vercel.app/posts/What-is-http) |
| 지승 | -                                                                        |
| 서연 | -                                                                        |
| 동현 | -                                                                        |
| 재연 | -                                                                        |

[⬆️ 맨 위로 이동 ⬆️](#HTTP)
