# 실행 컨텍스트

## 1. 🤔 호이스팅이란?

코드가 실행되기 전 선언들이 해당 스코프의 최상단으로 끌어 올려진 것 같은 현상

- var : 선언과 함께 undefined로 초기화
- let, const : 초기화되지 않은 상태로 선언만 메모리에 저장
- 함수 선언식 : 함수 전체로 초기화
- 함수 표현식 : 초기화되지 않은 상태로 선언만 메모리에 저장

## 2. 🤔 Lexical Environment에 대해 설명해주세요.

컨텍스트를 구성하는 환경 정보들을 사전처럼 모아놓은 것.

environmentRecord와 outerEnvironmentReference로 구성된다.

environmentRecord에는 현재 컨텍스트와 관련된 식별자 정보들이 저장된다. 

outerEnvironmentReference는 현재 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조한다.

environmentRecord로 인해 호이스팅이 가능해지고, outerEnvironmentReference로 인해 스코프 체인이 가능해진다.

## 3. 🤔  전역 scope를 사용했을 때 장단점에 관해 설명해주세요.

자바스크립트에는 스코프 체인(scope chain)이라는 개념이 있는데, 내부 함수에서는 외부 함수의 변수에 접근이 가능하지만 외부 함수에서는 내부 함수의 변수에 접근할 수 없습니다. 

내부 함수에서는 변수를 먼저 해당 스코프에서 찾은 뒤, 만약 없으면 outer 스코프에서 찾고, 그렇게 타고 올라가다가 결국 전역 scope에서 변수를 찾습니다. 

따라서 전역 변수를 만들어서 작업하면 다른 개발자와 협업할 때 우연히 같은 변수 이름을 사용해서 이전의 변수를 덮어쓰는 불상사가 발생할 수도 있습니다. 

굳이 전역 변수의 장점을 꼽자면 함수 내의 지역 변수와 달리, 저장된 값이 사라지지 않는다는 점입니다.

## 4. 🤔 **실행 컨텍스트(Execution Context)에 대해 설명해주세요.**

실행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체입니다. 크게 `전역 컨텍스트` ,
`함수 컨텍스트` 2가지가 존재합니다.

### 실행 컨텍스트의 원칙 네가지

- 먼저 **전역 컨텍스트 하나 생성 후, 함수 호출 시마다 컨텍스트가 생깁니다.**
- 컨텍스트 생성 시 컨텍스트 안에 **변수객체**(**arguments, variable), scope chain, this**가 생성됩니다.
- 컨텍스트 생성 후 함수가 실행되는데, 사용되는 변수들은 변수 객체 안에서 값을 찾고, **없다면 스코프 체인을 따라 올라가며 찾습니다.**
- 함수 실행이 마무리되면 해**당 컨텍스트는 사라집니다.**(클로저 제외) 페이지가 종료되면 전역 컨텍스트가 사라집니다

## 5. 🤔  함수 선언문과 함수 표현식의 차이점을 설명해주세요.

```tsx
// 함수 선언문
function a () { ... }

// 함수 표현식
const a = function () { ... }
```

함수 선언문은 호이스팅이 일어납니다.

함수 표현식은 호이스팅이 일어나지 않습니다.

함수 표현식은 표현식이 담긴 변수만 호이스팅이 일어나서 `undefined`로 동작을 하다가 할당문을 만나면 그 때 서야 함수를 제대로 사용할 수 있습니다.

그래서 우리는 코드를 위에서 아래로 읽는 습성이 있기 때문에 함수 선언 이전에 함수를 사용한다면 조금 이상하게 느껴질 수도 있습니다.

그리고 협업에 있어서도 **함수 선언문** 보다는 **함수 표현식**이 조금 더 안전합니다.

(만약 코드가 1000, 10000줄 이렇게 되는데 저 아래에 `add` 라는 함수를 선언해서 사용했는데, 위에서 다른 개발자가 `add` 라는 함수를 또 선언해서 사용한다면 아래에 있는 `add`를 생각하고 사용한 개발자는 위에 존재하는 `add` 가 아래 `add` 를 덮는다는 것을 예상하지 못합니다. 이럴 때 함수 표현식으로 함수를 선언한다면 아래에 존재하는 `add` 함수를 사용하는 코드는 그 아래에 존재할 것이니까 이런 예상치 못한 동작을 막을 수 있습니다.)

## 6. 🤔 outerEnvironmentReference에 대해서 간략하게 설명해주세요.

`outerEnvironmentReference`은 해당 컨텍스트에서 참조하는 외부 컨텍스트를 말합니다.

`outerEnvironmentReference`는 해당 함수가 선언된 위치의 `LexicalEnvironment`를 참조하고, 코드 상에서 어떤 변수에 접근하려고 할 때 현재 컨텍스트의 `LexicalEnvironment`를 탐색해서 발견되면 그 값을 반환하고, 발견하지 못할 경우 다시 `outerEnvironmentReference`에 담긴 `LexicalEnvironment`를 탐색하는 과정을 거칩니다. 끝까지 찾지 못한다면 `undefined`를 반환합니다. (스코프 체인 과정)

## 7. 🤔  해당 코드의 로그가 어떻게 찍힐지 예측해보세요.

```tsx
function a (x) {
	console.log(x); // (1)
	var x;
	console.log(x); // (2)
	var x = 2;
	console.log(x); // (3)
}

a(1);
```

- 정답
    1. `1`
    2. `1`(undefined라고 예상할 수 있지만 그 바로 윗 줄에 `var x` 가 호이스팅 되면서 (1)과 똑같이 출력이 됨
    3. `2` 

## 8. 🤔 해당 코드의 결과를 말해주세요.

```jsx
var a = 1;
var outer = function () {
	var inner = function () {
		console.log(a); // (1)
		var a = 3;
	};
	inner();
	console.log(a); // (2)
};
outer();
console.log(a); // (3)
```

- 정답
    
    > undefined
    > 
    
    > 1
    > 
    
    > 1
    > 
- 왜 이런 결과가 나올까요?
    
    > 스코프 체인 상에 있는 변수라고 하더라도 무조건 접근 가능하지 않습니다.
    > 
    
    식별자 `a`의 경우 전역 공간, inner 내부에서도 선언 했기 때문에
    inner 내부에서 `a`를 접근하려고 하면  inner 스코프의 `LexicalEnvironment`부터 검색 합니다.
    
    inner 내부에서 존재하기 때문에 스코프체이닝으로 더 이상 검색을 진행 하지 않고 즉시 반환을 하게 됩니다.
    

## 9. 🤔 실행 컨텍스트 객체에는 어떤 정보들이 담길까요?

실행 컨텍스트 객체는 활성화 시점에 `VariableEnvironment`, `LexicalEnvironment`, `ThisBinding` 의 정보를 수집 합니다.

- `VairialbeEnvironment` 의 경우 `LexicalEnvironment`와 최초에는 동일한 정보를 담고, 초기 상태를 유지 한다는 특징을 가지고 있습니다.
- `LexicalEnvironment` 의 경우 `environmentRecord` , `outerEnvironmentReference`
    - `environmentRecord` 에는 매개변수 명, 변수의 식별자, 선언한 함수의 변수명이 담겨 집니다.
    - `outerEnvironmentReference` 는 직전 실행 컨텍스트의 `LexicalEnvironment` 를 참조 합니다.
- ThisBinding의 경우 this 식별자가 바라봐야 할 대상 객체를 가리킵니다.

## 10. 🤔 실행 컨텍스트가 생성되는 소스코드의 종류는 무엇이 있나요?

- **전역 코드**
    - 전역 영역에 존재하는 코드
    - 전역 변수, 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩.
    - 전역 스코프 생성
- **함수 코드**
    - 함수 내에 존재하는 코드.
    - 지역변수, 매개변수, arguments 객체를 관리.
    - 함수 스코프 생성
- **Eval 코드**
    - eval 함수로 실행되는 코드.
    - eval 실행 컨텍스트가 생성된다.
- **모듈 코드**
    - 모듈 내부에 존재하는 소스코드를 말한다.
    - 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다
    - 독립적인모듈 실행 컨텍스트 생성.

## 11. 🤔  this 에 대해 아는대로 설명해주세요

- this 는 strict mode 와 non-strict mode 에 차이가 있습니다.
- this 는 함수를 호출한 방법에 의해 결정됩니다.
- ES5 에서 함수를 어떻게 호출했는지 상관하지 않고 this 값을 설정할 수 있는 bind 메서드를 도입했습니다.
- ES5 에서부터는 화살표 함수를 통해 렉시컬 컨텍스트 안의 this 값을 유지할 수 있습니다.

## 12. 🤔  this 바인딩이란?

- this 의 호출 방식에 따라 this 가 특정 객체에 연결되는 것입니다.
- this 의 바인딩은 **1) 일반 함수 내부, 2) 메서드 내부, 3) 생성자 함수 내부, 4) call, apply, bind 등을 통한 호출 방식** 이 있습니다.
    - **1) 일반 함수 내부** → `글로벌 객체`와 바인딩
    - **2) 메서드 내부** → `메서드를 호출한 객체`와 바인딩
    - **3) 생성자 함수 내부** → `생성자 함수가 생성할 인스턴스`와 바인딩
    - **4) Call, Apply, Bind 메서드 사용시** → `메서드 첫번째 인수`로 전달하는 객체에 바인딩