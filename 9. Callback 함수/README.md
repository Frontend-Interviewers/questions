# 콜백함수 질문

속성: https://www.notion.so/cb2309e0abbe487fa09bb94415d254e1

## 1. 🤔 콜백 함수란 무엇인가요?

다른 코드의 인자로 넘겨주는 함수

디자인 패턴 중 하나인 옵저버(Observer) 패턴에서 나온 개념으로써 객체의 상태 변화(이벤트)가 발생 하였을 경우에 이러한 사실을 함수를 통해 전달하게 되는데, 이를 콜백 함수라고 합니다. 콜백 함수를 사용하는 이유는 서버로 어떠한 요청을 보낸다고 가정할 때 응답을 기다리는 동안 가만히 시간을 버리는 것이 아닌, 다른 작업을 함으로써 동기적인 코드에 비해 성능을 향상시킬 수 있기 때문입니다.

## 2. 🤔 콜백 지옥을 해결하는 방법은 무엇이 있나요?

- 콜백 함수인 익명함수를 **기명함수**로 바꾸는 방법
- **Promise 객체**, **async/await** 활용하는 방법

## 3. 🤔 콜백 함수, Promise, async/await의 에러처리는 어떻게 하나요?

- 콜백 함수 - try… catch…문
- Promise - `.catch()`
- async/await - try… catch…문

## 4. 🤔 콜백 함수와 Promise의 차이점은 무엇인가요?

### 콜백 함수

- 비동기적인 작업을 수행하기 위해서 이런 형태가 자주 등장하긴 하는데, 가독성이 떨어지고 코드를 수정하기도 어려움
- 콜백 함수를 익명 함수로 전달하는 과정이 반복되어서 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상, 즉 콜백 지옥에 빠질 수 있음
- 그래서 등장한 것이 아래의 Promise

### Promise

- ES6에 등장한 자바스크립트 비동기적인 코드를 동기적으로 보이게 하기 위한 문법
- resolve, reject와 같은 함수를 제공함
- resolve를 호출하면 then 메서드로, reject를 호출하면 catch 메서드로 이동함.
- 위에서 봤듯 then, catch와 같은 메서드를 제공해서 **명시적**으로 비동기적인 코드를 동기적으로 처리할 수 있음

## 5. 🤔  아래에서 콘솔에 무엇이 찍힐지 맞춰보세요

```jsx
var obj1 = {
	name: 'obj1',
	func: function () {
		console.log(this);
	}
}

setTimeout(obj1.func, 1000);
```

- 정답
    
    **1초(1000ms)후에 전역객체(브라우저에서는 `window`, node에서는 `global`)이 출력됩니다.**
    
    이유는 비동기 함수의 콜백 함수로 전달해는데 **콜백 함수도 일반 함수**이기 때문에 일반 함수의 this는 명시적으로 this를 바인딩 한 것이 아니라면 전역 객체를 참조하게 됩니다.
    

## 6. 🤔 **Callback 대신에 Promise를 사용할 때의 장점과 단점은 무엇인가요?**

**장점**

- 가독성이 떨어질 수 있는 콜백 지옥을 피할 수 있습니다.
- `.then()`을 이용하여 가독성 좋은 연속적인 비동기 코드를 쉽게 작성할 수 있습니다.
- `Promise.all()`을 사용하여 병렬 비동기 코드를 쉽게 작성할 수 있습니다.
- Promise를 사용하면 ~~콜백만 사용하는 코딩방식에 있는~~ 다음과 같은 상황이 발생하지 않습니다:
    - 콜백을 너무 빨리 호출함
    - 콜백을 너무 늦게 호출하거나 호출하지 않음
    - 콜백을 너무 적게 호출하거나 너무 많이 호출함
    - 필요한 환경/매개변수를 전달하는데 실패함
    - 발생가능한 오류/예외를 무시함

**단점**

- 약간 더 복잡한 소스코드(논쟁의 여지가 있음).
- ES2015를 지원하지 않는 이전 브라우저에서 이를 사용하기 위해서는 polyfill을 로드해야 함.

## 7. 🤔 **동기, 비동기 함수의 차이점을 설명하세요.**

**동기 함수**는 블로킹인 반면, 비동기 함수는 그렇지 않습니다. 동기 함수에서는 다음 명령문이 실행되기 전에 앞 명령문이 완료됩니다. 이 경우, 프로그램은 명령문의 순서대로 정확하게 평가되고 명령문 중 하나가 매우 오랜 시간이 걸리면 프로그램 실행이 일시중지됩니다.

**비동기 함수**는 일반적으로 파라미터를 통해서 콜백을 받고, 비동기 함수가 호출된 후 즉시 다음 줄 실행이 계속됩니다. 콜백은 비동기 작업이 완료되고 호출 스택이 비어 있을 때만 호출됩니다. 웹 서버에서 데이터를 로드하거나 데이터베이스를 쿼리하는 등의 무거운 작업을 비동기식으로 수행하여, 메인 스레드가 긴 작업을 완료할 때까지 블로킹하지 않고 다른 작업을 계속할 수 있습니다(브라우저의 경우 UI가 중지됨).

**콜스택 관련 글 (Callback Queue)**

[[JavaScript] 호출 스택(Call Stack)과 이벤트 루프(Event Loop)](https://jongbeom-dev.tistory.com/119)

## 8. 🤔 async/await에 대해 설명해주세요.

async/await은 비동기 코드를 동기식으로 표현하는 더 나은 방법으로 ES2017에 등장했습니다. async와 await는 항상 같이 붙어 있어야 합니다. await 모드는 Promise 객체를 받아 처리하고, 만약 비동기 함수가 아닌 동기적 함수라면 리턴 값을 그대로 받습니다. async 함수는 Promise 객체를 통해 비동기적으로 처리된 내용을 동기적인 코드 진행 순서로 보여주는 역할을 합니다.

## 9. 🤔 콜백 함수 내부의 this에 다른 값을 바인딩 하는 방법은 어떤 것이 있을까요?

1. this를 다른 변수에 담아 콜백 함수로 활용할 함수에서 this 대신 그 변수를 사용하기
2. bind를 이용하여 바인딩하기

등이 있습니다. 1번의 경우 너무 번거롭기 때문에 bind나 call을 이용하여 명시적으로 바인딩 하는 방법이 좀 더 간편합니다.

- 코드
    
    ```jsx
    var obj1 = {
    	name: 'obj1',
    	func: function() {
    		console.log(this.name);
    	}
    };
    setTimeout(obj1.func.bind(obj1), 1000);
    
    var obj2 = { name: 'obj2' };
    setTimeout(obj1.func.bind(obj2), 1500);
    ```
    

## 10. 🤔 다음 두 코드는 어떤 차이점이 있을까요?

```jsx
function repeat(n, f) {
   for (var i = 0; i < n; i++){
      f(i); 
   }
}

// 1 ❌
repeat(5, function (i) {
	if (i % 2) console.log(i);
});

// 2 ✅
var logOdds = function (i) {
   if (i % 2) console.log(i);
}

repeat(5, logOdds)
```

1번의 경우 콜백 함수로서 전달된 `함수 리터럴`은 **고차함수가 호출될 때마다 평가되어 함수 객체를 생성** 합니다. 그렇기에 콜백 함수를 다른 곳에서 호출하거나 콜백 함수를 전달받는 함수가 자주 호출 된다면 2번의 경우와 같이 전달하는 것이 더 효율적 입니다.